## linux运维笔记-->程序的加载和状态

### 五态模型

​	在linux中把三态模型（就绪态、运行态、阻塞态）更新为了五态模型。

​	在五态模型中，进程分别为新建态、终止态、运行态、就绪态、阻塞态。

### 程序加载过程

​	从操作系统调用fork()函数加载进程至**就绪态**，等待cpu调度。cpu按优先级进行调度，此进程变为**运行态**。当进程自己调用内核提供的exit()函数或被系统使用SIGKILL时，进程终止变为**僵尸态**。进程收到内核SIGSTOP和SIGTSTP信号时，进程变为**停止态**，此时需要收到SIGCONT信号才可以被唤醒进入**就绪态**。在**运行态**未申请到所需资源可转入**不可中断等待态**直到资源被满足进入**就绪态**；在**运行态**未申请到所需资源还可转入**可中断等待态**直到资源被满足或者被信号或者被中断唤醒进入**就绪态**。

### 控制台查看

​	使用"ps aux"查看所有进程。使用"top"动态显示所有进程，按Q退出，按K输入PID结束进程。

| USER           | PID    | %CPU      | %MEM       | VSZ                | RSS                                | TTY    | STAT     | START    | TIME     | COMMAND            |
| -------------- | ------ | --------- | ---------- | ------------------ | ---------------------------------- | ------ | -------- | -------- | -------- | ------------------ |
| 拥有进程的用户 | 进程id | 占用cpu比 | 占用内存比 | 分配的虚拟内存大小 | 已使用的虚拟内存大小（包含共享库） | 终端号 | 进程状态 | 开始时间 | 运行时长 | 启动命令（进程名） |

​	使用"kill"加信号数字加进程号，对进程进行操控。

```shell
kill -9 9023 //强制结束pid为9023的进程
```

​	使用"killall"加信号加进程名，结束所有此进程名的进程。

```shell
killall -9 java //强制结束所有进程名为java的进程
```



### 父子进程、组进程

​	在程序中使用fork()函数可以开启子进程，这时执行此fork()函数的进程为父进程。从fork()函数之后开启子进程，写时拷贝读时共享父进程的进程上下文、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等，PID不拷贝。

​	fork()函数在创建好子进程后还有返回值。在父进程里返回子进程的id，在子进程里返回0，创建失败返回-1。getpid()可以获取当前进程id，getppid()可以获取父进程id。

​	使用exit()结束此进程，等价与return 0，在括号里可以传退出状态。

### 内存泄漏

​	在进程使用malloc或者new在堆上申请空间时需要手动释放。有几个子进程释就放几次。不释放会造成内存泄漏。

​	可以使用"valgrind"加可执行文件，查看是否有内存泄漏，如果有LEAK SUMMARY则有内存泄漏。

### 子进程的回收

​	使用wait()可以回收一次，多次需要循环回收。使用waitpid()回收特定pid的子进程。除了回收它还会等待子进程结束。

### 孤儿进程和僵尸进程

​	父进程运行结束但子进程还在运行，此为孤儿进程。此时会由内核init（1号进程）回收。

​	父进程还在运行，但子进程已经结束但未wait()或waitpid()回收。内核无法回收，使用killall把父子进程一起结束才能结束。

### 进程替换

​	使用内核提供的exec()函数可以启动其他程序作为进程来替换当前进程。因此在此之后的代码都不会被执行，除非用fork()新建子进程再exec()替换。

​	exec()是一个函数组的名称，其中有execl()、execlp()


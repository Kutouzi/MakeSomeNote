## c++笔记-->指针

### 左值和右值

1. 地址是左值，数值是右值。c++里判断方法为是否可以取地址，可以取就是左值，不可为右值

   ```c++
   /*右传左。a是某个内存空间的地址，1是数值*/
   int a = 1;
   ```

2. 右可传给左，，左可以传给左，但左不能传给右。

   ```c++
   /*错误写法。左不可给右*/
   1 = a;
   /*左可以给左*/
   int a = 1;
   int b = a;
   ```

3. 右值不可变，左值可以变。

   ```c++
   /*错误写法。右值不可变*/
   1 = 2;
   ```

### 指针

#### 解指针

对指针使用*是解指针，也被称为解引用，因为引用是一种被限制的指针

```c++
int number = 1;
int *p = &number;
/**p是解指针，也就是number。所以number被改为3*/
*p = 3;
/*p是地址，所以可以重新给p付一个地址*/
p = &number
```

#### 常量指针与指针常量

const只修饰右边的符号，把*换成&也是同种规律

1. 常量指针

    ```c++
    /*此例子是const锁地址的存储空间*/
    int numberA = 1;
    int numberB = 2;
    /*此时*p(解引用)不能被赋值*/
    const int *p = &numberA; //等价于int const *p = &numberA;
    /*这个是不可行的*/
    *p = 3;
    /*这个是可行的*/
    p = &numberB;
    ```

2. 指针常量
    ```c++
    /*此例子是const锁地址*/
    int numberA = 1;
    int numberB = 2;
    /*此时p(地址)不能被赋值*/
    int * const p = &numberA;
    /*这个是可行的*/
    *p = 3;
    /*这个是不可行的*/
    p = &numberB;
    ```

3. 常量指针常量

    ```c++
    /*此例子是const锁地址以及地址的存储空间*/
    int numberA = 1;
    int numberB = 2;
    /*此时p(地址)不能被赋值*/
    int const * const p = &numberA; //等价于const int * const p = &numberA;
    /*这都是不可行的*/
    *p = 3;
    p = &numberB;
    ```

#### 指针数组和数组指针

```c++
int a[5] ={1,2,3,4,5};
int *p = nullptr;
/*指针数组。可以存放五个int类型指针的一个数组*/
int *array[5] = {p,p,p,p,p};
/*数组指针。即array指向五个int类型的数组，只要符合这种int[5]都可以指向*/
int (*array)[5] = a;
```

### 引用

引用是一种被限制的指针。和指针的区别是引用不能再被重新指向新地址，等同于指针常量(例如int * const a)这样的定义

```c++
/*相当于起别名*/
int a=10;
int &b =a;
```

#### 左值引用和左值常引用

这是一个过度的东西，知道有就行

```c++
/*绑定到左值*/
const int &number = 2;
/*错误写法。因为引用可以改变值，而右值不可变*/
int &number = 2;
```

左值引用使用场合是希望只将变量的地址传进去的情况。这两个函数相等，但引用方便写

```c++
int func(int &a,int &b){
    return a+b;
}
int func(int *a,int *b){
    return *a+*b;
}
```

左值常引用使用场合是希望将变量的地址传进去的同时还要兼容传右值的情况。由于右值不可变，需要const变为常引用。这两个函数还是相等，但引用方便写

```c++
/*可以接收1、2这种数值，也能接收a,b这种地址*/
int func(const int &a,const int &b){
    return a+b;
}
int func(const int *a,const int *b){
    return *a+*b;
}
```

#### 右值引用

将值都转右值，强行左转右用move()。这是一个过度的东西，知道有就行

使用场合是希望只传数值进去

```c++
/*可以接收1、2这种数值，但不能接收a、b这种地址，除非move(a)这样强转后就可以接收*/
int func(int &&a){
    int &&b = 1;  //它不能用auto声明，否则就不叫右值引用了
    return a+b;
}
int main(){
    int&& a = 5;
    func(a);  //这个是不能传的，被声明为右值引用的变量是左值，变量里面的内容才是右值
    func(move(a));  //这个就可以了，move做了一个把a里面的内容提取出来的操作，变成func(5)就可以了
}
```

#### 万能引用

通过上面知道当一个函数想接受左值同时又想接收右值时，只能把它改成const常量。但这导致了它的左值也不能修改（右值本来就不可以修改），并且这种情况指针也无能为力了（指针不能取一个右值的地址，因为它可能在寄存器里面甚至可能是立即数，比如函数返回值大多在ax寄存器里）。

```c++
int func(const int &a,const int &b){
    a=a+1; //但由于不能改const，这个会编译出错，当想对传入值再做点什么操作就很麻烦了
    return a+b;
}
int main(){
    int a=1,b=2;
    /*左右值都可以传，但第二个明明传的是左值却不能修改*/
    cout<< func(1,2) <<endl;
    cout<< func(a,b) <<endl;
}
```

为了解决这个问题有了万能引用，当参数是个模板类型，以及让auto进行推导出来的，是万能引用。本质是因为发生了类型推导，根据传进来的参是左值还是右值来进行推导它是左值引用还是右值引用

```c++
template<class T>
int func(T &&a,T &&b){
    a=a+1;
    auto &&c = 1; //这个也是万能引用
    return a+b;
}
int main(){
    int a = 1;
    int b = 2;
    /*左右值都可以传，而且能改*/
    cout<< func(1,2) <<endl;
    cout<< func(a,b) <<endl;
}
```

#### 万能转发

上面都是为了万能转发而作准备的，弄这么复杂的最终目的是为了提高性能，让函数传参的时候不要进行复制，而是进行移动。这在对象传递的时候很重要，复制对象是比直接移动对象慢一个指数级的

```c++
template<class T>
void print_t(T t){
    cout<<typeid(t).name()<<endl;
}
/*这里无论是左值还是右值传进来，因为函数参数是地址，因此传进来什么都会变成左值*/
template<class T>
void temp(T &&t){
    /*要想让它不变成左值，需要万能引用来转发，这样保持了它传进来前的性质*/
    print_t(forward<T>(t));
}
int main(){
    /*传左值*/
    int a = 1;
    temp(a);
    /*传右值*/
    temp(1);
}
```


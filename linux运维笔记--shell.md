## linux运维笔记-->shell

无需解释

### 全局配置文件

加载系统变量共享给所有shell程序使用

1. 文件位于(这些变量切换用户或者不同用户登录都会全部重新加载一遍)：

  - /etc/profile：登录了的账户可用变量

  - /etc/profile.d/*.sh：用户登录系统后，会执行profile.d下面所有的\*.sh

  - /etc/bashrc  所有账户可用变量，官方推荐吧全局变量放这里，但基本和同目录下的profile一样

  - ~/.bashrc：只有此用户可用的全局变量

  - ~/.bash_profile：只有此用户可用的全局变量

  - ...

2. 查看环境变量命令

	```bash
	# 查看系统变量
	env
	# 查看系统变量+函数+自定义变量
	set
	
3. 常用环境变量

   | 变量     | 用处                                                  |
   | -------- | ----------------------------------------------------- |
   | HOME     | 当前用户主目录                                        |
   | PATH     | 设置搜索路径，和windows的一样                         |
   | SHELL    | 当前shell解析使用哪一个解析器                         |
   | HISTFILE | 显示当前用户执行命令的历史列表文件/root/.bash_history |
   | PWD      | 显示当前所在路径                                      |
   | OLDPWD   | 显示之前路径                                          |
   | HOSTNAME | 显示当前主机名                                        |
   | HOSTTYPE | 显示主机的架构                                        |
   | LANG     | 设置当前系统语言环境                                  |

4. 重载环境变量

   ```bash
   source 绝对路径+文件名
   # 如
   source /etc/profile
   ```


### 局部变量的增删查

可以在本shell内访问到

```bash
# 新建，第二个为不可修改的变量
变量名=值
readonly 变量名=值
# 查找
${变量名}
# 删除
unset 变量名
```

### 全局变量的增删查

可以在本shell和子shell内访问到（本shell里面还可以bash一个脚本，这个脚本叫子shell），但重启后就没了

```bash
#新建
export 变量名1 变量名2 ...
```

### 特殊变量

```bash
#用于脚本文件执行时传入的参数
${n}
${1}~${9} #获取输入第一到第九个输入的参数，一到九可以不带花括号
${0} #获取当前脚本的名称
```

```bash
#获取所有输入参数的个数
${#}
```

```bash
#不用双引号括起来，获取所有输入参数，用于以后输出所有参数
$* $@ #结果一样为$1 $2 $3 ...
#用双引号括起来的获取所有参数，用于以后输出所有参数
"$*" #参数拼接为一个字符串为"$1 $2 $3 ..."
"$@" #参数不拼接，单独成字符串为"$1" "$2" "$3" ...
```

```bash
#用于获取上一个shell命令的退出状态码，或者是函数的返回值（shell命令都有返回值）
$?
```

```bash
#用于获取当前shell环境的进程id号
$$
```

```bash
<& #输入重定向到文件描述符
>& #输出重定向到文件描述符
< #输入重定向
> #输出重定向
```

```shell
#加在脚本执行后，显示脚本执行过程
-x
```



### 变量子串

加井号统计变量字符数

```shell
a=114514
echo ${#a}
#结果是6
#等效于下面的，但上面的效率高
echo ${a} |wc -L
```

截取字符，从0开始

```shell
a=1145141919810
echo ${a:0:5}
#结果是114514
#等效于下面的，但上面的效率高(cut是从1开始)
cho ${a} |cut -c 1-6
```

删除内容，#从开头开始删；%从尾部开始删。都是只删第一个匹配到的包括自身。##和%%是删除所有匹配到的。

```shell
a=1145141919810
echo ${a#*5}
#结果是141919810
a=1145141919810
echo ${a%8*}
#结果是1145141919
a=1145141919810
echo ${a##1}
#结果是4549980
```

替换内容，/来替换左匹配到的第一个，//来替换匹配到的所有

```shell
a=1145141919810
echo ${a//1/2}
#结果是2245242929820
```

注：上面的所有操作不会改变变量本身的内容，因此需要另一个变量来存储结果

### 变量扩展

如果没有被赋值或为空，就给输出-后面的东西

```shell
echo ${a:-default}
#结果是default
echo ${a}
#结果是
```

```shell
a=114514
echo ${a:-default}
#结果是114514
```

如果没有被赋值或为空，就给它赋值

```shell
echo ${a:=default}
#结果是default
echo ${a}
#结果是default
```

如果没有被赋值或为空，就错误输出

```shell
echo ${a:?没有参数}
#结果是没有参数
#并且$?返回的是1，也就是这个程序错误退出返回1（正常退出是返回0）
```

### 逻辑拼接命令

```shell
#前一个命令无论如何都执行后面的
;
#前一个命令成功就执行后面的
&&
#前一个命令失败就执行后面的
||
#一般这样用，如果cat返回0就输出a，否则就输出b，类似c++的三元表达式
cat a.txt 
&& {
	echo a 
}
|| {
	echo b
	echo c
}
```

### 调用命令

```shell
a=`hostname -I`
```

### 交互赋值

```shell
read -p "输入ip:" -t 30 addr
输入ip: 192.168.1.1
echo ${addr}
#结果是192.168.1.1
```

### 随机输出

```shell
#不常用
date +%N|md5sum
#这个容易
$RANDOM
#难但可自定义
tr -cd 'a-z' </dev/urandom|head -c位数
#这个也容易
openssl rand -base64 位数
```

### 运算

需要在双小括号内进行，不支持浮点数

```shell
a=1
b=2
((c=${a}+${b}))
echo ${c}
#结果是3
```

推荐awk计算，支持浮点数，支持多个同时算

```shell
x=1
y=2
echo awk -v a=${x} -v b=${y} 'BEGIN{print a*4,a/b}'
#结果是4 0.5
```

判断变量是否为数字

```shell
a=1
#注意空格
expr ${a} + 1
echo $?
#结果是0
#如果不是0，变量存的就不是数字
```

转换进制，bc也可以用作计算器并且支持浮点，但可能要额外安装

```shell
echo "obase=16;10"|bc
#结果是A
```

### 条件

```shell
#和test一样，方括号更通用，注意要前后加空格
[  ]
#支持正则表达式
[[  ]]
```

判断文件

```shell
#文件是否存在
[ -f /etc/hosts ]
echo $?
#结果是0
```

| 参数        | 作用                  |
| ----------- | --------------------- |
| -d          | 目录是否存在          |
| -f          | 文件是否存在          |
| -e          | 是否存在              |
| -r          | 文件是否存在并有r权限 |
| -w          | 文件是否存在并有w权限 |
| -x          | 文件是否存在并有x权限 |
| -s          | 文件是否为空          |
| 源 -nt 目标 | 源比目标更新          |
| 源 -ot 目标 | 源比目标更旧          |

判断变量值

| 参数          | 作用                            |
| ------------- | ------------------------------- |
| -n "源"       | 变量是不是为空，是空就返回false |
| "源" = "目标" | 判断内容是否一致，一致返回true  |

判断数值

| 参数 | 作用     |
| ---- | -------- |
| -gt  | 大于     |
| -ge  | 大于等于 |
| -lt  | 小于     |
| -le  | 小于等于 |
| -eq  | 等于     |
| -ne  | 不等于   |

### 判断

```shell
#标准格式，注意中括号用法要两边加空格
if [ 条件 ]
then
  做的事
elif [ 条件 ]
then
  做的事
fi
```

### 选择

```shell
case "${变量}" in
  字符串1)
    做的事
    ;;
  字符串2 | 字符串3 | 字符串4) #这里表示三种匹配都进入这个分支
    做的事
    ;;
  [a-z]) #这里也可以用正则
    做的事
    ;;
  *)
    做的事 #最后一个是通配
esac
```

### 循环

循环中可以加continue和break，作用和c++的一样

```shell
while [ 条件 ]
do
  做的事
done
```

```shell
for((i=1;i<=10;i++))
do
  做的事
done
```

```shell
for 变量 in {1..3}
do
  做的事
done
```





### 退出

```shell
#退出脚本，后面跟一个整数，0是正常退出，其他数字自定义
exit 0
```



### 交互和非交互Shell

交互式：用户输入一个命令会立即返回一个结果

非交互：只执行命令

### 登录和非登录Shell

区别是输不输入账户和密码，并且初始化环境变量流程不一样:

登录：/etc/profile -> /etc/profile.d/*.sh -> /此用户/.bash_profile -> /此用户/.bashrc -> /etc/bahsrc

非登录：/此用户/.bashrc -> /etc/bashrc -> /etc/profile.d/*.sh

注：非登录用户指/etc/passwd/里，带有nologin的就是非登录用户，它们不需要登录就能用shell。使用

```bash
bash
```

切换非登录环境，使用

```bash
$0
```

可以看当前环境是否登录，输出-bash就是登录，bash就是没登录，不能在脚本里用

### 用户的切换

使用

```bash
# 切换用户并且是此用户的登录环境
su 用户名 -l
# 切换用户但是非登录环境
su 用户名
# 切换到当前用户的非登录环境
bash
```


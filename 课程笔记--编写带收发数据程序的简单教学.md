[TOC]
## 课程笔记-->编写带收发数据程序的简单教学

文章默认认为已略微了解java或c#的编程基础
最终目的是编写出最简单的类似QQ的收发信息程序
以下会使用c#来进行编程,其他的语言编写思路一样,参考帮助手册模仿即可
全文以叙事的方式来进行总结,基本思想是分析需求→寻求方法→解决问题

------

### 一. 循环

一个类似QQ基本的信息收发程序,需要有收信息和发信息两个功能模块.
收信息需要不停运行否则会漏收信息→使用while(true)来无限接收

```C#
namespace SAR
{
	class Program
	{
		static void Main(string[] args)
		{
			receiveMassage();
			sendMassage();
		}
		static void receiveMassage()	#收信息功能
		{
			while(true)
			{
				#接收的方法
			}
		}
		static void sendMassage()	#发信息功能
		{
			#发送的方法
		}
	}
}
```
但在程序运行中会被收信息占用,因此程序无法继续运行
因此我们找到了一个解决办法叫线程

------

### 二. 线程

线程可以理解为一个程序的分支程序,可实现在一个程序内同时运行好几个函数
用法例如这样

```C#
static void Main(string[] args)
{
	Thread th_1 = new Thread(A);
	Thread th_2 = new Thread(B);
	th_1.Start();
	th_2.Start();
	/*把写好的函数放到它构造函数里,再调用Start函数启用线程就行了*/
	Console.ReadKey();
}
static void A()
{
	int i = 0;
	while (i != 100)
	{
		Console.WriteLine("A");
		i++;
		Thread.Sleep(200);	//静态函数,让线程停止200ms
	}
}
static void B()
{
	int j = 0;
	while (j != 100)
	{
		Console.WriteLine("B");
		j++;
		Thread.Sleep(200);
	}
}
```
于是我们将线程运用到了程序里
```C#
public Form1()
{
	ThreadPool.SetMaxThreads(8, 8);
    ThreadPool.QueueUserWorkItem(new WaitCallback(getLocalIP));
}
```
之后开始寻找方法将数据发出去
数据在网络间都是转换成0和1传输的,传到电脑上需要用一个方式来识别这串数字
这个转换和识别方式叫做编码和解码

#####  附1-1:线程池

之后会需要创建很多个线程,我们会觉得很麻烦
因此我们找到了一个办法叫线程池
它可以让系统自动为加进去的函数分配线程,函数运行完还会自动回收线程
它的写法类似这样,先设置个最大线程数
```C#
ThreadPool.SetMaxThreads(3, 3);	//设置个最大线程数,不然线程太多可能卡
								//第一个参数是work线程数,第二个是io线程数
```
再把写好的函数(比如上面的A)传进去
```C#
ThreadPool.QueueUserWorkItem(A);
```
我们会发现他需要传入的是函数的地址,而在java和c#中没有指针来获取地址
于是我们找到了一个办法叫委托,另一个办法叫回调

#####  附1-2:委托

它的写法类似这样
```C#
/*创建委托,需要声明为类的成员变量*/
delegate void DeleA();
/*在函数内分配空间,把A委托给它,此时deleA就可以当指针用了*/
DeleA deleA = new delegate(A);
```
于是就可以这样把A传进去给它执行了
```C#
ThreadPool.QueueUserWorkItem(new WaitCallback(delegate { A(); }));
```

#####  附1-3:回调

当然也可以不用委托,因为WaitCallback函数本来就是个委托
在它的命名空间是这样被定义的
```C#
namespace System.Threading
{
    //
    // 摘要:
    //     表示要由线程池线程执行的回调方法。
    //
    // 参数:
    //   state:
    //     包含回调方法要使用的信息的对象。
    [ComVisible(true)]
    public delegate void WaitCallback(object state);
}
```
但是它需要一个根类,所以得把A()变成A(object state),即使用不到state也要这样做
```C#
ThreadPool.QueueUserWorkItem(new WaitCallback(A));
```
------

### 三. 编码和解码

编码中最常用的是UTF-8
因此用Encoding提供的静态函数来获取输入字符串的对应的UTF8编码
```C#
/*编码*/
void encodingSTR(string str)
{
   int strbytelen = Encoding.UTF8.GetByteCount(str);
   byte[] encodingstr = Encoding.UTF8.GetBytes(str);
}
string decodingSTR(byte[] bytestream)
{
   int strbytelen = Encoding.UTF8.GetDecoder().GetCharCount(bytestream, 0, bytestream.Length);
   char[] chars = new char[strbytelen];
   string decoding = Encoding.UTF8.GetDecoder().GetChars(bytestream, 0, strbytelen,chars,0).ToString();
   return decoding;
}
```
将数据编码好后接下应该是准备发送和接收了
但是根据网络的协议规定,需要把数据加上报头才能在网络中传送
加报头的工作就让叫套接字的函数来做吧

------

### 四. 套接字

```C#
/*声明了一个套接字,初始化它为网络簇,套接字类型为流,协议类型为Tcp*/
Socket localSocket = new 			Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
```
有了加上报头的数据,就可以在网络中传输了
但还没告诉它往哪里传,地址和端口会让它找到该去的地方

------

###  五. 地址和端口

要告诉它往哪里发,我们需要知道对面的地址和端口,还有可能用到自己的地址和端口
```C#
/*获取IP地址,这里我的平板在局域网的ip是192.168.0.3*/
IPAddress ipaddr = IPAddress.Parse("192.168.0.3");
/*建立一个可以存放地址加端口的空间,把得到的地址端口给它,0表示本机任意可用端口*/
IPEndPoint IPep = new IPEndPoint(ipaddr,0);
/*把这个地址加端口的空间装在套接字里*/
localSocket.Bind(IPep);
```

------

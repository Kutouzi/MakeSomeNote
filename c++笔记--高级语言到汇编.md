## c++笔记-->高级语言到汇编

统一为x64下，一个寄存器为八个字节

### 通用寄存器

r8、r16、r32、r64都表示通用寄存器

当数据量小于四个字节，编译器有可能将八个字节的寄存器分成两半用。以RAX为例子，就会变为EAX

- AX：通常存放运算结果、函数返回值
- BX：通常存放存储器(内存)的地址
- CX：通常存放循环操作的计数
- DX：常用来存放外接设备的端口地址

### 立即数寄存器

- i8、i16、i32、i64：表示立即数，立即数就是一个数值，例如1、2、3等

- imm8、imm16、imm32、imm64：表示立即数寄存器，用来存储立即数

### 指针寄存器

- SP：指向程序栈区顶部
- BP：指向程序栈区底部

### 变址寄存器

- SI：通常存放字符串或数组的地址
- DI：通常存放字符串或数组要操作对象的地址

### 存储器(内存)

- m8、m16、m32、m64：表示内存

### 汇编指令

|        指令         |                             作用                             |
| :-----------------: | :----------------------------------------------------------: |
|     mov 目标,源     | 将源的值赋给目标，源必须是数值或空间，如果是地址要用[]表示空间 |
|    [偏移量+地址]    |     表示空间，中括号内是地址，而且可以在里面进行地址计算     |
|      word ptr       |                    声明内存空间为两个字节                    |
|      dword ptr      |                    声明内存空间为四个字节                    |
|      qword ptr      |                    声明内存空间为八个字节                    |
|      call 地址      |                           调用函数                           |
|      push 目标      |        把目标存入栈的空间里，同时栈顶指针向低地址移动        |
|      pop 目标       |   把栈空间内栈顶的数据弹出到目标，同时栈顶指针向高地址移动   |
|   lea 目标,[地址]   |                     将[]中的地址赋给目标                     |
|         ret         |                 函数返回，跳转到call的下一句                 |
|     xor 目标,源     |            将源和目标进行异或运算，然后赋值给目标            |
|     add 目标,源     |             将源和目标进行加运算，然后赋值给目标             |
|     sub 目标,源     |             将源和目标进行减运算，然后赋值给目标             |
|       inc 源        |                        将源的值自增1                         |
|       dec 源        |                        将源的值自减1                         |
|      jmp 地址       |                 直接跳转到此地址往下执行指令                 |
| jne/je/jle/jge 地址 |   条件跳转，检查各种标志位，前面会跟着条件指令test、cmp等    |
|     cmp 目标,源     |   比较目标和源的数值，根据不同比较结果而改变ZF和CF等标志位   |

### 函数调用和栈平衡

在程序最开始运行时，BP和SP都是同一个地址（程序是被操作系统调用的一个函数，也在栈区。在被调用同时，操作系统会给一个BP作为程序栈底）

使用call调用函数，要进行push，push个数就是此函数参数的个数。每push一个数据，SP的地址就会对应增加的空间而减小（注意确实是减小，因为栈是高地址往低地址延伸的）

  ```assembly
  0000000A12114F16  push 1
  0000000A12114F1A  push 2
  0000000A12114F1E  push 3
  0000000A12114F20  call 0000000C21AD6C1h
  0000000a12114F25  add esp,12
  ```

执行call时会把call的下一句指令的地址push到栈内以便返回，然后跳转到方法区内找到此函数的地址。

```assembly
0000000C21AD6C1  jmp 0000000F00D717C0h
```

再转到函数调用

```assembly
;把函数调用前的栈底地址压入栈中
0000000F00D717C0  push rbp
;再把现在栈顶和栈底对齐
0000000F00D717C1  mov rbp,rsp
;分配给此函数栈空间，做法是栈顶指针上移
0000000F00D717C3  sub rsp,0C0h
;保护上一个函数的现场，防止上一个函数在寄存器里面的值被这个函数修改
0000000F00D717C9  push rbx
0000000F00D717CA  push rsi
0000000F00D717CB  push rdi
```

在函数调用结束，也就是函数尾部

```assembly
;恢复上一个函数的现场，做法是将栈顶的值赋值给这些寄存器
0000000F00D717E8  pop rdi
0000000F00D717E9  pop rsi
0000000F00D717EA  pop rbx
;回收分配给这个函数的栈空间
0000000F00D717EB  add rsp,0C0h
;进行地址对齐
0000000F00D717F1  mov rsp,rbp
;把现在栈顶的地址（即上一个函数的栈底地址）还给基址寄存器
0000000F00D717F3  pop rbp
;函数返回，做法是pop出现在栈顶的地址（即之前call保存的下一个语句的地址），然后跳转到这个地址
0000000F00D717F4  ret
```

在函数ret之后，会紧接着对SP进行增加，也就是平衡回函数调用之前的地址。堆栈平衡编译器会帮忙做，一般不需要手动平衡除非自己写汇编。

注：windows的api函数在函数内部已经进行栈平衡，所以在外面看不到add

### 内存布局



### c++内联汇编

x32下使用__asm{}

```c++
int main(){
    int number = 1;
    __asm{
        mov rax,number
    }
    return 0;
}
```

x64下写.asm汇编文件，作为函数引用到.hpp头文件内，最后才可以在.cpp文件使用

### 逆向技巧

- []之内必定是地址，无论里面进行什么运算，出来的结果必定是地址

- 如果看到[rax]，那么寄存器rax里面必定为地址。此时极大概率对应“解指针”的操作

  ```assembly
  mov dword ptr [rax],8
  ```

  此时再往上找如果有lea操作那么极有可能是“指针赋值”的操作



